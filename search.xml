<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>布隆过滤器原理</title>
    <url>/2024/10/20/BloomFilter/</url>
    <content><![CDATA[<h3 id="1-什么是布隆过滤器"><a href="#1-什么是布隆过滤器" class="headerlink" title="1. 什么是布隆过滤器"></a>1. 什么是布隆过滤器</h3><p>以下定义来至百度百科：</p>
<ul>
<li>布隆过滤器（英语：Bloom Filter）是1970年由伯顿·霍华德·布隆（Burton Howard Bloom）提出的。它实际上是由一个很长的二进制向量和一系列随机映射函数组成的。布隆过滤器可以用于检索一个元素是否在一个集合中。 它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</li>
</ul>
<p>由此我们可知布隆过滤器主要由两个部分组成：位数组和多个映射函数（哈希函数）。</p>
<ul>
<li><strong>位数组</strong>：初始化为一组固定长度的二进制位（默认全为 0）。</li>
<li><strong>哈希函数</strong>：使用多个独立的哈希函数（如 k 个），对输入元素进行哈希处理，生成 k 个哈希值。</li>
</ul>
<p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20241027235221.png"></p>
<p>Bloom Filter 使用一个较大的bit数组进行保存所有的数据，数组中的每个元素都只占用1 bit，并且每个元素只能是 0 或者 1，这也是布隆过滤器节省内存的核心所在。<br>我们设想1000w个元素，它只需要 <strong>1000000Bit &#x2F; 8 &#x3D; 125000 Byte &#x3D; 125000 &#x2F; 1024 KB ≈ 122 KB</strong> 的空间。显然它非常的节省内存，但是如果所有的二进制位数全部占完，接下不管来什么它都会返回1，也就是说添加到集合中的元素越多，误报的可能性就越大</p>
<h3 id="2-布隆过滤器的原理介绍"><a href="#2-布隆过滤器的原理介绍" class="headerlink" title="2. 布隆过滤器的原理介绍"></a>2. 布隆过滤器的原理介绍</h3><p><strong>插入操作</strong>：</p>
<ol>
<li>当插入一个元素时，使用 k 个哈希函数计算出 k 个哈希值。</li>
<li>将这 k 个哈希值对应的位数组的索引位置设置为 1。</li>
</ol>
<p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20241028095609.png"></p>
<p>如上图所示，当输入一个“hello”，预设3个哈希函数，将输出2，5，6，我们把相应位置为 1。假设另一个输入“word”，哈希函数输出6，9，10。此时你应该注意到，索引6已经被先前的“hello”标记了。此时，我们已经使用了”hello“和”word”两个输入值，填充了位向量，当前向量的标记状态为：</p>
<p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20241028095757.png"></p>
<p><strong>查询操作</strong>：</p>
<ol>
<li>当查询一个元素是否在集合中时，使用相同的 k 个哈希函数计算出 k 个哈希值。</li>
<li>检查这 k 个位置的值：<ul>
<li>如果所有对应的位都是 1，则该元素可能在集合中（可能误判）。</li>
<li>如果任何一个位为 0，则该元素肯定不在集合中。</li>
</ul>
</li>
</ol>
<p>前面我们已经添加了两个输入值，这时我们使用3个哈希函数对“搜索的值”进行哈希函数，并查看其生成的索引值。假设，当我们搜索“java”时，3个哈希函数输出的3个索引值分别是5，6，9：</p>
<p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20241028100853.png"></p>
<p>从上图我们可以发现，相应的索引位都被置位 1 ，这意味着我们可以说“java”可能已经插入到集合中。当然明显这是错误的的，产生的原因是由于哈希碰撞导致的巧合而将不同的元素存储在相同的比特位上。好在布隆过滤器有个可预测的误判率（FFP）：</p>
<p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20241028101432.png"></p>
<ul>
<li>n 是已经添加的元素的数量</li>
<li>k 是哈希的次数</li>
<li>m 布隆过滤器的长度（如比特数组的大小）</li>
</ul>
<p>有上可知，在极端情况下，当布隆过滤器没有空闲空间时（满），每一次查询都会返回 true 。这也就意味着 m 的选择取决于期望预计添加元素的数量 n ，并且 m 需要远远大于 n 。</p>
<p>实际情况中，布隆过滤器的长度 m 可以根据给定的误判率（FFP）的和期望添加的元素个数 n 的通过如下公式计算：</p>
<p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20241028101645.png"></p>
<p>了解完上述的内容，我们可以得出一个结论：<strong>当我们搜索一个值的时候，若该值经过 K 个哈希函数运算后的任何一个索引位为 ”0“，那么该值肯定不在集合中。但如果所有哈希索引值均为 ”1“，则只能说该搜索的值可能存在集合中</strong>。</p>
<h4 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3. 优缺点"></a>3. 优缺点</h4><ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>空间效率高</strong>：相对于存储实际元素，布隆过滤器所需的内存占用非常少，适合处理大规模数据。</li>
<li><strong>快速查询</strong>：布隆过滤器的查询操作时间复杂度为 O(k)，k 通常是一个小的常数，因此查询速度非常快。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>误判</strong>：布隆过滤器可能会误判元素存在（即返回 true 的情况下，元素实际上不在集合中），无法准确判断。</li>
<li><strong>无法删除</strong>：标准的布隆过滤器不支持删除操作，因为删除某个元素可能会影响其他元素的存在性判断。</li>
</ul>
</li>
</ul>
<h4 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h4><p>布隆过滤器广泛应用于许多场景，特别是在需要快速判断元素存在性且资源有限的情况下，例如：</p>
<ul>
<li><strong>网络爬虫</strong>：用于判断 URL 是否已被访问，避免重复抓取。</li>
<li><strong>数据库</strong>：在执行查询前先检查数据是否存在，以减少对数据库的无效请求。（针对解决缓存穿透的问题）</li>
<li><strong>分布式系统</strong>：在分布式缓存中使用，减少跨节点的请求。</li>
<li><strong>大数据处理</strong>：在数据流处理和实时分析中，快速判断数据是否已处理。</li>
</ul>
<h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h4><p>布隆过滤器是一种非常实用的数据结构，尤其适用于高效存储和查询大规模数据。尽管它存在误判的风险，但在许多场景中，其空间和时间效率使其成为一种理想的选择。在实际应用中，合理配置哈希函数和位数组的大小，可以有效控制误判率，进一步提升布隆过滤器的性能。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>缓存问题</tag>
        <tag>布隆过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title>线程创建的几种方式</title>
    <url>/2025/02/05/CreateThread/</url>
    <content><![CDATA[<h1 id="线程创建的几种方式"><a href="#线程创建的几种方式" class="headerlink" title="线程创建的几种方式"></a>线程创建的几种方式</h1><h2 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1.继承Thread类"></a><strong>1.继承Thread类</strong></h2><p>最为简单直接的方式，直接通过继承<code>Thread</code>类，并重写<code>run()</code>方法。</p>
<p><strong>步骤：</strong></p>
<ol>
<li><p>创建一个类继承<code>Thread</code>。</p>
</li>
<li><p>重写 <code>run()</code> 方法，将线程要执行的的代码写在<code>run</code>方法中。</p>
</li>
<li><p>创建线程对象，通过<code>start()</code>方法启动线程。</p>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ul>
<li><p>简单直接，适合快速创建简单线程。</p>
</li>
<li><p>由于<code>Java</code>不支持多继承，如果已经继承了其他类，就不能使用这种方式。</p>
</li>
</ul>
<h2 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2.实现Runnable接口"></a>2.实现Runnable接口</h2><p>相比于继承<code>Thread</code>，实现<code>Runnable</code>接口更为灵活，可以避免<code>java</code>单继承的限制</p>
<p><strong>步骤：</strong></p>
<ol>
<li><p>创建一个类实现<code>Runnable</code>接口。</p>
</li>
<li><p>实现 <code>run()</code> 方法，将线程要执行的的代码写在<code>run</code>方法中。</p>
</li>
<li><p>创建<code>Thread</code>对象，并将<code>Runnable</code>对象传递给<code>Thread</code>的构造方法。</p>
</li>
<li><p>调用<code>start()</code>方法启动线程。</p>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Runnable is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ul>
<li><p>更灵活，可以实现 <code>Runnable</code> 接口的同时继承其他类。</p>
</li>
<li><p>更加适合资源共享场景，可以将同一个 <code>Runnable</code> 实例传递给多个线程。</p>
</li>
</ul>
<h2 id="3-使用callable和Future"><a href="#3-使用callable和Future" class="headerlink" title="3.使用callable和Future"></a>3.使用callable和Future</h2><p><code>Callable</code> 和 <code>Runnable</code> 类似，但 <code>Callable</code> 可以有返回值，并且可以抛出异常。需要配合 <code>Future</code> 或 <code>FutureTask</code> 使用。</p>
<p><strong>步骤：</strong></p>
<ol>
<li>创建一个类实现<code>Callable</code> 接口。</li>
<li>实现<code>call()</code>方法 ,并定义返回值类型</li>
<li>使用<code>ExecutorService</code>提交任务，获得<code>Future</code>对象</li>
<li>通过<code>Future</code>的<code>get()</code>方法获得线程结果。</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//通过Future实现</span></span><br><span class="line">        <span class="comment">/*ExecutorService executor = Executors.newSingleThreadExecutor();</span></span><br><span class="line"><span class="comment">        Future&lt;Integer&gt; future = executor.submit(new MyCallable());</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;callable返回值：&quot; + future.get());</span></span><br><span class="line"><span class="comment">        &#125; catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        executor.shutdown();*/</span></span><br><span class="line">        <span class="comment">//通过FutureTask实现</span></span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">myCallable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(myCallable);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;callable返回值：&quot;</span> + ft.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ul>
<li>可以获取线程的执行结果。</li>
<li>支持抛出异常的处理。</li>
<li>更加适合复杂的线程操作，特别是需要返回结果时。</li>
</ul>
<h2 id="4-使用线程池（ExecutorService"><a href="#4-使用线程池（ExecutorService" class="headerlink" title="4.使用线程池（ExecutorService)"></a>4.使用线程池（ExecutorService)</h2><p>线程池管理一组线程，可以避免频繁创建和销毁线程的开销，提高性能。</p>
<p><strong>步骤：</strong></p>
<ol>
<li>创建一个线程池，例如使用 <code>Executors</code> 类。</li>
<li>将任务提交给线程池执行。</li>
<li>线程池可以管理多个线程的执行，并可复用现有线程。</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; is running&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ul>
<li>提高了资源利用率，特别适合大量短小任务的执行。</li>
<li>可以控制线程的数量，避免过多线程导致的资源竞争。</li>
</ul>
]]></content>
      <categories>
        <category>Thread</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ - 延迟队列</title>
    <url>/2025/03/12/RabbitMQ%20-%20%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>延迟队列在我们的日常生活中很常见，比如超时取消订单功能，优惠卷过期，消息延时推送等功能。RabbitMQ是一个广泛的消息队列中间件，它支持延迟队列的功能，我们可以通过设置消息的TTL (过期时间)  结合死信队列实现，或通过RabbitMQ的插件实现延迟队列。</p>
<h2 id="1-什么是延迟队列："><a href="#1-什么是延迟队列：" class="headerlink" title="1.什么是延迟队列："></a>1.什么是延迟队列：</h2><p><strong>延迟队列</strong>是一个特殊类型的消息队列，其核心特点是任务或消息在被发送者送到队列后，并不会马上被消费，而是等待预设的时间到了后才被消费者消费。在分布式系统中，延迟队列是一个常见的工具，他允许程序能够按照预定的时间处理任务（定时任务）。</p>
<h2 id="2-基于RabbitMQ实现延迟队列原理"><a href="#2-基于RabbitMQ实现延迟队列原理" class="headerlink" title="2.基于RabbitMQ实现延迟队列原理"></a>2.基于RabbitMQ实现延迟队列原理</h2><h3 id="2-1-RabbitMQ中的TTL"><a href="#2-1-RabbitMQ中的TTL" class="headerlink" title="2.1.RabbitMQ中的TTL"></a>2.1.RabbitMQ中的TTL</h3><p>首先我们要知道RabbitMQ中的TTL，他是RabbitMQ中的一个消息或者队列的一个属性，表明一条消息或者这个队列中的所有消息的最大存活时间。如果一条消息设置了TTL属性或者进入了设置TTL属性的队列，那这条消息如果<strong>在TTL设置的时间内没有被消费</strong>，就会变为<strong>死信</strong>。(消息TTL和设置了TTL队列如果同时存在，以最小的为准)。</p>
<h4 id="2-1-1-队列设置TTL"><a href="#2-1-1-队列设置TTL" class="headerlink" title="2.1.1.队列设置TTL"></a>2.1.1.队列设置TTL</h4><p>在设置队列的时候设置队列的“x-message-ttl”属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;QueueA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">queueA</span><span class="params">()</span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//设置死信交换机</span></span><br><span class="line">    map.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Exchange_Dead);</span><br><span class="line">    <span class="comment">//设置死信路由键</span></span><br><span class="line">    map.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">    <span class="comment">//设置TTL 单位ms</span></span><br><span class="line">    map.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(Queue_A).withArguments(map).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-消息设置TTL"><a href="#2-1-2-消息设置TTL" class="headerlink" title="2.1.2.消息设置TTL"></a>2.1.2.消息设置TTL</h4><p>对每条消息设置TTL</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> MessageBuilder.withBody(message.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">        .setExpiration(String.valueOf(ttl)) <span class="comment">//设置TTL 单位ms</span></span><br><span class="line">        .build();</span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XC&quot;</span>, msg);</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-两者的区别"><a href="#2-1-3-两者的区别" class="headerlink" title="2.1.3.两者的区别"></a>2.1.3.两者的区别</h4><p>通过队列设的TTL属性，一旦消息过期就会被丢弃(如果配置了死信队列就会被丢到<strong>死信队列</strong>中)，而通过消息设置TTL，消息到期也不一定会马上被丢弃，主要是队列的先进先出特性，只有过期的消息到了队列的队首，才会被丢弃或进入死信队列，这样如果队列前面有很多未到期的消息，但是后面后来的消息已经到期了但是前面的消息还有没有到期，造成消息积压，这样即使已经过期的消息也许还能存活较长时间。</p>
<h2 id="3-RabbitMQ实现延迟队列"><a href="#3-RabbitMQ实现延迟队列" class="headerlink" title="3.RabbitMQ实现延迟队列"></a>3.RabbitMQ实现延迟队列</h2><p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20250311232201.png"></p>
<p>前面我们简绍了RabbitMQ中的TTL属性，基于这个属性我们可以结合死信队列实现延迟队列，当生产者发送消息到一个没有消费者的队列，这个消息TTL到期后变成死信消息进入死信队列然后被消费者消费，这样是不是就是实现了消息不会马上被消费，而是等TTL（预设时间）到期后才被消费。</p>
<h3 id="3-1-队列TTL"><a href="#3-1-队列TTL" class="headerlink" title="3.1.队列TTL"></a>3.1.队列TTL</h3><p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20250312161238.png"></p>
<p>创建两个队列QA和QB,两个队列分别设置TTL10S和30S，然后创建一个交换机X和死信交换机Y，由于QA和QD没有指定消费者所有消息最终会变为死信进入死信队列，然后被延迟消费。</p>
<h4 id="3-1-1-配置和代码"><a href="#3-1-1-配置和代码" class="headerlink" title="3.1.1.配置和代码"></a>3.1.1.配置和代码</h4><p><strong>项目结构：</strong></p>
<p>rabbitmq<br>├── src<br>│   ├── main<br>│   │   ├── java<br>│   │   │   └── com.luyseon.rabbitmq<br>│   │   │       ├── config<br>│   │   │       │   └── rabbitmqConfig.java<br>│   │   │       ├── consumer<br>│   │   │       │   └── DelayQueueConsumer.java<br>│   │   │       ├── controller<br>│   │   │       │   └── publishController.java<br>│   │   │       └── RabbitmqApplication.java<br>│   │   └── resources<br>│   │       └── application.yml<br>│   └── test<br>│       └── (测试代码目录)<br>└── (其他项目文件)</p>
<p><strong>通过Bean统一声名交换机和队列：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">rabbitmqConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">Exchange_X</span> <span class="operator">=</span> <span class="string">&quot;X&quot;</span>;</span><br><span class="line">    <span class="comment">//死信交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">Exchange_Dead</span> <span class="operator">=</span> <span class="string">&quot;Y&quot;</span>;</span><br><span class="line">    <span class="comment">//队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">Queue_A</span> <span class="operator">=</span> <span class="string">&quot;QA&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">Queue_B</span> <span class="operator">=</span> <span class="string">&quot;QB&quot;</span>;</span><br><span class="line">    <span class="comment">//死信队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">Queue_Dead</span> <span class="operator">=</span> <span class="string">&quot;QD&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明交换机X</span></span><br><span class="line">    <span class="meta">@Bean(&quot;ExchangeX&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">exchangeX</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(Exchange_X);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明死信交换机Y</span></span><br><span class="line">    <span class="meta">@Bean(&quot;ExchangeY&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">exchangeDead</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(Exchange_Dead);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明队列A</span></span><br><span class="line">    <span class="meta">@Bean(&quot;QueueA&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueA</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//设置死信交换机</span></span><br><span class="line">        map.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Exchange_Dead);</span><br><span class="line">        <span class="comment">//设置死信路由键</span></span><br><span class="line">        map.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">//设置TTL 单位ms</span></span><br><span class="line">        map.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(Queue_A).withArguments(map).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明队列B</span></span><br><span class="line">    <span class="meta">@Bean(&quot;QueueB&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//设置死信交换机</span></span><br><span class="line">        map.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Exchange_Dead);</span><br><span class="line">        <span class="comment">//设置死信路由键</span></span><br><span class="line">        map.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">//设置TTL 单位ms</span></span><br><span class="line">        map.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">30000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(Queue_B).withArguments(map).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明死信队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;QueueDead&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueDead</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(Queue_Dead).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定队列A到交换机X的路由键为XA</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingXA</span><span class="params">(<span class="meta">@Qualifier(&quot;QueueA&quot;)</span> Queue queueA,</span></span><br><span class="line"><span class="params">                             <span class="meta">@Qualifier(&quot;ExchangeX&quot;)</span> DirectExchange exchangeX)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> BindingBuilder.bind(queueA).to(exchangeX).with(<span class="string">&quot;XA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定队列B到交换机X的路由键为XB</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingXB</span><span class="params">(<span class="meta">@Qualifier(&quot;QueueB&quot;)</span> Queue queueB,</span></span><br><span class="line"><span class="params">                             <span class="meta">@Qualifier(&quot;ExchangeX&quot;)</span> DirectExchange exchangeX)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> BindingBuilder.bind(queueB).to(exchangeX).with(<span class="string">&quot;XB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定死信队列到死信交换机Y的路由键为YD</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingDead</span><span class="params">(<span class="meta">@Qualifier(&quot;QueueDead&quot;)</span> Queue queueDead,</span></span><br><span class="line"><span class="params">                               <span class="meta">@Qualifier(&quot;ExchangeY&quot;)</span> DirectExchange exchangeDead)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> BindingBuilder.bind(queueDead).to(exchangeDead).with(<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消息发送者：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/ttl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">publishController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendMsg/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;,发送一条信息给两个TTL队列:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XB&quot;</span>,<span class="string">&quot;ttl为30s的队列：&quot;</span> + message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XA&quot;</span>,<span class="string">&quot;ttl为10s的队列：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>监听消息消费者：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayQueueConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;QD&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveDelayQueue</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;，收到延迟队列的消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过浏览器访问：<a href="http://localhost:8080/ttl/sendMsg/%7Bhhhh%7D">http://localhost:8080/ttl/sendMsg/{hhhh}</a> 可以看到日志打印：</p>
<p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20250312195652.png"></p>
<p>这样成功实现了延迟队列，但是如果这样使用，每需要一个新的时间需求的延迟，就需要我们新增一个队列 ，这显然不行。</p>
<h3 id="3-2-消息TTL"><a href="#3-2-消息TTL" class="headerlink" title="3.2.消息TTL"></a>3.2.消息TTL</h3><p>我们新增一个队列QC,该队列不设置TTL时间。这个QC队列是通用的，我们通过生产者发送消息时设置TTL。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">rabbitmqConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//前面一样..</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//声名队列C（队列不设置TTL）</span></span><br><span class="line">    <span class="meta">@Bean(&quot;QueueC&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueC</span><span class="params">()</span>&#123;</span><br><span class="line">        HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        map.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Exchange_Dead);</span><br><span class="line">        map.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(Queue_C).withArguments(map).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定队列C到交换机X的路由键为XC</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingC</span><span class="params">(<span class="meta">@Qualifier(&quot;QueueC&quot;)</span> Queue queueC,</span></span><br><span class="line"><span class="params">                            <span class="meta">@Qualifier(&quot;ExchangeX&quot;)</span> DirectExchange exchangeX)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueC).to(exchangeX).with(<span class="string">&quot;XC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息发送者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sendMsg/&#123;message&#125;/&#123;ttl&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message, <span class="meta">@PathVariable</span> <span class="type">int</span> ttl)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;当前时间：&#123;&#125;，ttl为&#123;&#125;ms的队列：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), ttl, message);</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> MessageBuilder.withBody(message.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">            .setExpiration(String.valueOf(ttl))  <span class="comment">//设置消息TTL</span></span><br><span class="line">            .build();</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XC&quot;</span>,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发送两个请求</p>
<p><a href="http://localhost:8080/ttl/sendMsg/%E4%BD%A0%E5%A5%BD">http://localhost:8080/ttl/sendMsg/你好</a> 1&#x2F;20000</p>
<p><a href="http://localhost:8080/ttl/sendMsg/%E4%BD%A0%E5%A5%BD">http://localhost:8080/ttl/sendMsg/你好</a> 2&#x2F;10000</p>
<p>按理来说应该第二个请求先到达死信队列，但是结果却是：</p>
<p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20250312204454.png"></p>
<p>造成这样的情况就是前面所说的消息挤压的问题，第一个消息的延时时间很长，而第二个消息的延时时间很短，由于队列的先进先出特性，消息只有到达队列顶端才会被消费。</p>
<h3 id="3-3-使用RabbitMQ插件优化"><a href="#3-3-使用RabbitMQ插件优化" class="headerlink" title="3.3.使用RabbitMQ插件优化"></a>3.3.使用RabbitMQ插件优化</h3><p>针对这个问题，我们可以使用RabbitMQ官方提供的一个插件解决。在官网上 <a href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a>, 下载 rabbitmq_delayed_message_exchange 插件，然后解压放置到 RabbitMQ 的插件目录。 进入 RabbitMQ 的安装目录下的 plgins 目录，执行下面命令让该插件生效，然后重启 RabbitMQ，具体教程这里不做过多讲解。</p>
<p>安装好后我们在RabbitMQ的新增交换机页面的Type选可以看见这个<strong>x-delayed-message</strong>:</p>
<p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20250312205920.png"></p>
<p>通过这个插件我们消息延迟的位置将不是在队列，而是在交换机，TTL到达后会进入队列，然后被消费。</p>
<p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20250312210337.png"></p>
<h4 id="3-3-1-配置和代码"><a href="#3-3-1-配置和代码" class="headerlink" title="3.3.1.配置和代码"></a>3.3.1.配置和代码</h4><p>我们重新配置一个交换机 <strong>delayed.exchange</strong> 和队列 <strong>delayed.queue</strong>。</p>
<p><strong>config代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">delayedConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">Delayed_Exchange</span> <span class="operator">=</span> <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">Delayed_Queue</span> <span class="operator">=</span> <span class="string">&quot;delayed.queue&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">Delayed_Routing_Key</span> <span class="operator">=</span> <span class="string">&quot;delayed.routingKey&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CustomExchange <span class="title function_">delayedExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        HashMap&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        arguments.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);<span class="comment">// 声明交换机的类型，以及延迟消息的类型（direct直接型）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomExchange</span>(Delayed_Exchange, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, arguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(Delayed_Queue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingDelayed</span><span class="params">(<span class="meta">@Qualifier(&quot;delayedQueue&quot;)</span> Queue delayedQueue,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@Qualifier(&quot;delayedExchange&quot;)</span> CustomExchange delayedExchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedQueue).to(delayedExchange).with(Delayed_Routing_Key).noargs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>发送者：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sendDelayMsg/&#123;message&#125;/&#123;delayTime&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsgDelay</span><span class="params">(<span class="meta">@PathVariable</span> String message, <span class="meta">@PathVariable</span> Integer delayTime)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;当前时间：&#123;&#125;，发送一条信息给延迟队列：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), message);</span><br><span class="line">    rabbitTemplate.convertAndSend(delayedConfig.Delayed_Exchange, delayedConfig.Delayed_Routing_Key, message, msg -&gt; &#123;</span><br><span class="line">        msg.getMessageProperties().setDelayLong(Long.valueOf(delayTime));</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消息监听：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// delayed监听消息</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;delayed.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveDelayedQueue</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">    log.info(<span class="string">&quot;当前时间：&#123;&#125;，收到延迟队列的消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送两条消息，这个时候我们可以看到低延迟的先输出：</p>
<p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20250312214738.png"></p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为单个节点挂掉导致延时队列不可用或者消息丢失。</p>
]]></content>
      <categories>
        <category>延迟队列</category>
      </categories>
      <tags>
        <tag>延迟队列</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-体系结构</title>
    <url>/2025/03/18/JVM-Architecture/</url>
    <content><![CDATA[<h1 id="JVM体系结构"><a href="#JVM体系结构" class="headerlink" title="JVM体系结构"></a>JVM体系结构</h1><p>JVM（Java Virtual Machine，Java虚拟机 ）是一种抽象的计算机，它能够运行Java编译后生成的字节码文件（.class后缀的文件）。JVM充当了一个翻译官的角色，将开发者编写的Java代码转换为底层操作系统能够理解的指令。最为核心的特性是“一次编写，到处运行”，即通过JVM，Java程序可以在任何支持JVM的平台上运行，而无需修改代码。</p>
<p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20250312140051.png"></p>
<p>如图所示，可以知道JVM主要由四个部分组成：</p>
<ul>
<li><p>类加载子系统（ClassLoader）</p>
</li>
<li><p>运行时数据区 （Runtime Data Area）</p>
</li>
<li><p>执行引擎 （Execution Engine）</p>
</li>
<li><p>本地库接口 （Native Method Library）</p>
</li>
</ul>
<h2 id="1-类加载子系统"><a href="#1-类加载子系统" class="headerlink" title="1.类加载子系统"></a>1.类加载子系统</h2><h3 id="1-1-类的生命周期"><a href="#1-1-类的生命周期" class="headerlink" title="1.1.类的生命周期"></a>1.1.类的生命周期</h3><p>类加载过程包括了<code>加载</code>、<code>验证</code>、<code>准备</code>、<code>解析</code>、<code>初始化</code>五个阶段。其中，<code>验证</code>、<code>准备</code> 和 <code>解析</code> 这三个部分统称为连接。注意这几个阶段是<strong>按顺序开始，而不是按顺序进行或完成</strong>，通常都是交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p>
<p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20250315173231.png"></p>
<p><strong>加载：查找并加载类的二进制数据</strong></p>
<ul>
<li><p>通过类的全限定名，获取二进制字节流。</p>
</li>
<li><p>将这个二进制字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p>
</li>
<li><p>在Java堆中创建一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p>
<p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20250315183702.png"></p>
</li>
</ul>
<p><strong>验证：确保被加载类的正确性</strong></p>
<p>验证主要是确保Class文件的字节流包含的信息符合当前虚拟机的要求，并且对虚拟机不会造成危害。</p>
<p>主要分为：</p>
<ul>
<li><p>文件格式验证：是否符合Class文件的规范。 例如：文件开头是否是<code>0xCAFEBABE</code></p>
</li>
<li><p>元数据验证：</p>
<ul>
<li>这个类是否有父类。（除了Object这个类之外，其余的类都应该有父类）</li>
<li>这个类是否继承（extends）了被final修饰过的类。（被final修饰过的类表示类不能被继承）</li>
<li>类中的字段、方法是否与父类产生矛盾。（被final修饰过的方法或字段是不能被覆盖的）</li>
</ul>
</li>
<li><p>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p>
</li>
<li><p>符号引用验证：符号引用一组符号来描述引用的目标，符号可以是任何形式的字面量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = 3; // 字面量:3 符号引用：i</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>准备：为类的静态变量分配内存，并将其初始化为默认值</strong></p>
<p>为类变量（static）分配内存并设置类变量的初始值，这些内存都将在方法区中分配。</p>
<ul>
<li>static变量，分配空间在准备阶段完成（设置默认零值：0,null,false等），赋值在初始化阶段完成</li>
<li>static变量是final的基本类型，以及字符串常量，值已确认，赋值在准备阶段完成。</li>
<li>static变量是final的引用类型，那么赋值也会在初始化阶段完成。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">//准备阶段是默认0值，初始化时赋值10</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">//准备阶段直接赋值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>; <span class="comment">//准备阶段直接赋值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">//准备阶段是null,初始化阶段赋值</span></span><br></pre></td></tr></table></figure>

<p><strong>解析：把类中的符号引用转换为直接引用</strong></p>
<p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>
<p>比如：方法中调用了其他方法，方法名可以理解为符号引用，而直接引用就是使用指针直接指向方法。</p>
<p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20250315231205.png"></p>
<p><strong>初始化</strong></p>
<p>对类的静态变量，静态代码块执行初始化操作</p>
<ul>
<li>如果该类的直接父类尚未初始化，则优先初始化其父类。</li>
<li>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依此执行。</li>
</ul>
<p><strong>使用</strong></p>
<p>JVM开始从入口方法（前面加载阶段说的方法区的数据结构接口）开始执行用户的程序代码。</p>
<ul>
<li>调用静态类成员信息。（比如：静态字段、静态方法）</li>
<li>使用new关键字为其创建对象实例。</li>
</ul>
<p><strong>卸载</strong></p>
<p>当用户程序代码执行完毕后，JVM便销毁创建的Class对象，最后负责运行的JVM也退出内存。</p>
<h3 id="1-2-类加载器"><a href="#1-2-类加载器" class="headerlink" title="1.2.类加载器"></a>1.2.类加载器</h3><p>我们知道JVM只会运行二进制文件，而类加载器（ClassLoader）的主要作用就是将字节码文件加载到JVM中。现有的类加载器基本上都是java.lang.ClassLoader的子类，该类的只要职责就是用于将指定的类找到或生成对应的字节码文件，同时类加载器还会负责加载程序所需要的资源。</p>
<p><strong>类加载器种类</strong></p>
<img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20250315232708.png" style="zoom: 50%;" />

<p><code>启动类加载器</code>：Bootstrp ClassLoader，负责加载存放在JAVA_HOME\jre\lib下，启动类加载器是无法被java程序直接引用的，它由C++编写实现。</p>
<p><code>扩展类加载器</code>：ExtClassLoader，负责加载JAVA_HOME\jre\lib\ext目录中的类库。</p>
<p><code>应用程序类加载器</code>：Application ClassLoader，加载开发者自己编写的Java类。</p>
<p><code>自定义类加载器</code>：CustomizaClassLoader，开发者自定义类继承ClassLoader，实现自定义加载规则。</p>
<p>类加载器的体系并<strong>不是继承</strong>体系，而是<strong>委派体系</strong>，类加载器加载一个类时首先会先在自己的parent中查找类或资源，如果找不到才回到自己的本地查找。这种委托行为是为了避免相同的类被加载多次。</p>
<p><strong>寻找类加载器</strong> </p>
<p>一个类加载器的例子：（这个例子是对于java8）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        System.out.println(loader.getParent());</span><br><span class="line">        System.out.println(loader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@27c170f0</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>从上面结果我们可以看到比没有获取到ExtClassLoader的父类，原因是BootstrapClassLoader是C++实现的，找不到确定的返回父Loader的方式，所有返回null。</p>
<p><strong>双亲委派机制</strong></p>
<p>当一个类加载器在接到加载类的请求时，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p>
<ul>
<li><p>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</p>
</li>
<li><p>当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</p>
</li>
<li><p>如果BootStrapClassLoader加载失败(例如在JAVA_HOME&#x2F;jre&#x2F;lib里未查找到该class)，会使用ExtClassLoader来尝试加载；</p>
</li>
<li><p>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</p>
</li>
</ul>
<h2 id="2-运行时数据区"><a href="#2-运行时数据区" class="headerlink" title="2.运行时数据区"></a>2.运行时数据区</h2><h3 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1.程序计数器"></a>2.1.程序计数器</h3><p>程序计数器，线程私有的，是一块较小的内存空间，内部保存的字节码的行号。用于记录正在执行的字节码指令的地址。<strong>程序计数器是JVM规范中唯一一个没有规定出现OOM的区域</strong>，所以这个区域也不会进行GC回收。</p>
<p><strong>作用</strong></p>
<ul>
<li>在方法调用、分支、循环等控制流操作中，程序计数器用于定位下一条需要执行的指令。</li>
<li>存储指向下一条指令的地址（即即将执行的字节码指令的地址）。由执行引擎读取下一条指令。</li>
</ul>
<p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20250317104804.png"></p>
<p><strong>为什么程序计数器会设为线程私有？</strong></p>
<p>JVM虚拟机对于多线程是通过线程轮流切换并分配线程执行时间，在任何一个时间点只会执行一个线程，当这个线程时间片用完，就会线程挂起，然后处理器会切换到另外一个线程进行执行。这期间线程来回切换，每次切换回来就需要知道当前线程执行到哪里，所以为每个线程分配一个程序计数器，每个线程都独立计算，不会互相影响。</p>
<h3 id="2-2-虚拟机栈"><a href="#2-2-虚拟机栈" class="headerlink" title="2.2.虚拟机栈"></a>2.2.虚拟机栈</h3><p>Java 虚拟机栈(Java Virtual Machine Stacks)，每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame），对应着一次次 Java 方法调用，是<strong>线程私有</strong>的，生命周期和线程一致。（<strong>栈不存在垃圾回收问题</strong>)</p>
<p><strong>作用</strong></p>
<p>主管 Java 程序的运行，它保存<strong>方法的参数和局部变量、返回地址，并参与方法的调用和返回。</strong></p>
<p><strong>栈运行原理</strong></p>
<ul>
<li><p>每次调用一个方法时，JVM会为该方法创建一个新的栈帧，并将其压入当前线程的虚拟机栈中。在一条活动线程中，一个时间点上，只会有一个活动的栈帧。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void methodA() &#123;</span><br><span class="line">    methodB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void methodB() &#123;</span><br><span class="line">    // 方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当methodA调用methodB时，methodB的栈帧会被压入虚拟机栈中。</p>
</li>
<li><p>当方法执行完成，其对应的栈帧就会被弹出虚拟机栈（出栈）,并释放相关资源。如果有返回值，则返回值会被传递给调用者。</p>
</li>
<li><p>虚拟机栈可能抛出两种异常：</p>
<ul>
<li><p><code>StackOverflowError</code>：当栈深度超过限制时抛出。典型问题：递归调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">	m(); <span class="comment">// 抛出异常： java.lang.StackOverflowError</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>OutOfMemoryError</code>：如果虚拟机栈允许动态扩展，但在尝试扩展时无法申请到足够的内存，则会抛出这个异常。</p>
</li>
</ul>
</li>
</ul>
<p><strong>栈帧的内部结构</strong></p>
<p>每个栈帧中存储着：</p>
<ul>
<li>局部变量表<ul>
<li>用于存储方法的参数和方法内部定义的局部变量。</li>
<li>他是一个数据结构，按索引访问，支持基本数据类型和对象引用的存储。</li>
</ul>
</li>
<li>操作数栈<ul>
<li>是一个后进先出的栈活动，用于保存<strong>计算过程中的中间结果</strong>。</li>
<li>操作数栈作为方法执行的工作区，所有的计算操作（如加法、赋值等）都在这里完成。</li>
</ul>
</li>
<li>动态链路：<ul>
<li>指向运行时常量池中该栈帧所属方法的引用。</li>
<li><strong>动态链路的作用就是为了将符号引用转换为调用方法的直接引用</strong>。</li>
</ul>
</li>
<li>方法返回值：方法正常退出或异常退出的地址，如果正常返回，返回值会被传递给调用者。</li>
<li>一些附加信息</li>
</ul>
<p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20250318110059.png"></p>
<h3 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3.本地方法栈"></a>2.3.本地方法栈</h3><ul>
<li><p>本地方法栈与虚拟机栈类似，Java虚拟机栈用于管理 Java 方法的本地调用，而本地方法栈用于管理本地方法的调用。</p>
</li>
<li><p>本地方法栈也是线程私有的。</p>
</li>
<li><p>可能抛出两种异常：</p>
<ul>
<li><code>StackOverflowError</code>：当栈深度超过限制时抛出。</li>
<li><code>OutOfMemoryError</code>：如果虚拟机栈允许动态扩展，但在尝试扩展时无法申请到足够的内存，则会抛出这个异常。</li>
</ul>
</li>
<li><p>本地方法是使用 C 语言实现的。</p>
</li>
</ul>
<h3 id="2-4-堆"><a href="#2-4-堆" class="headerlink" title="2.4.堆"></a>2.4.堆</h3><p><strong>内存划分</strong></p>
<p>Java堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。堆中唯一的目的就是存放对象的实例，几乎所有对象的实例以及数据都在堆内存中。</p>
<p>虚拟机把堆内存逻辑上划分为两块区域（分代的唯一理由就是优化GC性能）：</p>
<ul>
<li><p>新生代（年轻代）：新对象和没达到一定年龄的对象都在年轻代。</p>
</li>
<li><p>老年代（养老区）：被长时间使用的对象。java1.8时，老年代和新生代比例：1：2。</p>
</li>
<li><p>元空间（JDK1.8 之前叫永久代）：类信息、静态变量、常量、编译后的代码，JDK1.8 之前占用 JVM 内存，JDK1.8 之后直接使用本地内存。</p>
</li>
</ul>
<p>为了避免方法区出现OOM，所以在Java1.8 中将堆上的<strong>方法区&#x2F;永久代</strong>给移动到了本地内存上，重新开辟一块空间，叫做<strong>元空间</strong>。</p>
<p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20250317171555.png"></p>
<p><strong>年轻代</strong></p>
<p>年轻代是所有对象创建的地方。当填充年轻代时，执行垃圾收集，这种垃圾收集称为Minor CG。年轻代被划分为三个部分：<strong>伊甸园</strong>（Eden Memory）和两个<strong>幸存区</strong>（Survivor Memory，被称为from&#x2F;to或s0&#x2F;s1），默认比例为：<strong>8：1：1</strong></p>
<ul>
<li>大多数新创建的对象都位于 Eden 内存空间中。</li>
<li>当 Eden 空间填满时，触发<strong>Minor GC</strong>（Young GC），并将所有幸存者对象移动到（<strong>复制算法</strong>）一个非空的Survivor区（如S0）中，另一个Survivor区保持为空。</li>
<li>下一次Minor GC时，存活对象从当前使用的Survivor（如S0）移动到另一个Survivor区（如S1），并清空原来的Survivor区。所有每次，一个幸存区总是空的。</li>
<li>如果对象的年龄达到阈值（默认15次）或Survivor区空间不足，则将其晋升到老年代。</li>
</ul>
<p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20250317183453.png"></p>
<p><strong>老年代</strong></p>
<p>老年代中包含那些经过许多轮小型GC（Minor GC）后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行。老年代垃圾收集通过主GC（Major GC），一般需要更长的时间。</p>
<p>大对象直接晋升为老年代，这样做的目的时避免Eden区和Survivor区之间发生大量的内存拷贝。</p>
<p><strong>元空间</strong></p>
<p>不管是 JDK8 之前的永久代，还是 JDK8 之后的元空间，本质都是<strong>对 Java虚拟机规范中方法区的实现</strong>。</p>
<p>在<strong>HotSpot JVM</strong>中，永久代（ ≈ 方法区）中用于存放类和方法的元数据以及常量池，比如Class和Method。每当一个类初次被加载时，它的元数据都会放到永久代中。</p>
<p>永久代是有大小限制的，由于永久代是放在 JVM管理的内存中的很容易造成内存溢出，所有Java8之后取消了永久代，而是在本地内存中开辟了一个元空间，元空间的大小仅受本地内存限制。</p>
<p><strong>设置堆内存大小和OOM</strong></p>
<p>Java堆内存大小在 JVM 启动的时候就确定了，我们可以通过<code>-Xmx</code>和<code>-Xms</code>设定：</p>
<ul>
<li><code>-Xmx</code>：用于设置最大堆内存大小。（默认大小为电脑内存大小&#x2F;4）</li>
<li><code>Xms</code>：用于设置初始堆内存大小。（默认为电脑内存大小&#x2F;64）</li>
</ul>
<p>这两个参数一般会设为相同值，其目的是为了能够在垃圾回收机制清理完堆区后不再需要重新分配计算堆的大小，从而提高性能。</p>
<p>如果堆的内存大小超过了<code>Xmx</code>设定的最大内存，就会抛出<code>outOfMemoryError</code>。</p>
<h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5.方法区"></a>2.5.方法区</h3><ul>
<li><p>方法区与Java堆一样是线程共享的内存区域。</p>
</li>
<li><p>主要存储类的信息、运行时常量池。</p>
</li>
<li><p>方法区的大小和堆空间一样，可以固定大小也可以选择可扩展，方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，Java虚拟机也会抛出内存溢出错误。</p>
</li>
<li><p>虚拟机启动时创建，关闭虚拟机释放。</p>
</li>
</ul>
<p><strong>方法区内部结构</strong></p>
<p>方法区用于存储已经被虚拟机加载的类型信息、运行时常量池、静态变量，即时编译器编译后的代码缓存等。</p>
<ul>
<li><strong>类型信息</strong>：<ul>
<li>类的全限定名、父类名 、实现的接口列表等。</li>
<li>类的访问修饰符（如<code>public</code>、<code>final</code>等）和字段、方法的相关信息。</li>
</ul>
</li>
<li><strong>运行时常量池</strong>：存储字面量和符号引用。</li>
<li><strong>静态变量</strong>：存储类的静态变量。</li>
<li><strong>即时编译器编译后的代码缓存</strong>： 即时编译器（JIT）将热点代码编译为本地机器码后，缓存到方法区中。</li>
</ul>
<p><strong>常量池</strong></p>
<p>在字节码为文件（.class后缀）中除了包含类的版本信息，字段，方法以及接口等信息之外，还包含常量池表（Constant Pool Table），它包含各种字面量和对类型、域和方法的符号引用。</p>
<p>查看字节码结构（类的基本信息、常量池、方法定义） javap -v xx.class</p>
<p>比如下面类的字节码结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">helloTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Classfile /D:/idea_java_projects/MyBlog-Code/test/target/classes/com/luyseon/testcode/test/helloTest.class</span><br><span class="line">  Last modified 2025-3-17; size 612 bytes  //最后修改的时间</span><br><span class="line">  MD5 checksum aa0f3151d1ddf5dc2c6858279573e939  //签名</span><br><span class="line">  Compiled from &quot;helloTest.java&quot;</span><br><span class="line">public class com.luyseon.testcode.test.helloTest</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52  //jdk版本 </span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:  //常量池表</span><br><span class="line">   #1 = Methodref          #6.#21         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #22.#23        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #24            // hello world</span><br><span class="line">   #4 = Methodref          #25.#26        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #27            // com/luyseon/testcode/test/helloTest</span><br><span class="line">   #6 = Class              #28            // java/lang/Object</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/luyseon/testcode/test/helloTest;</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               args</span><br><span class="line">  #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               MethodParameters</span><br><span class="line">  #19 = Utf8               SourceFile</span><br><span class="line">  #20 = Utf8               helloTest.java</span><br><span class="line">  #21 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #22 = Class              #29            // java/lang/System</span><br><span class="line">  #23 = NameAndType        #30:#31        // out:Ljava/io/PrintStream;</span><br><span class="line">  #24 = Utf8               hello world</span><br><span class="line">  #25 = Class              #32            // java/io/PrintStream</span><br><span class="line">  #26 = NameAndType        #33:#34        // println:(Ljava/lang/String;)V</span><br><span class="line">  #27 = Utf8               com/luyseon/testcode/test/helloTest</span><br><span class="line">  #28 = Utf8               java/lang/Object</span><br><span class="line">  #29 = Utf8               java/lang/System</span><br><span class="line">  #30 = Utf8               out</span><br><span class="line">  #31 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #32 = Utf8               java/io/PrintStream</span><br><span class="line">  #33 = Utf8               println</span><br><span class="line">  #34 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public com.luyseon.testcode.test.helloTest();  //构造方法</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/luyseon/testcode/test/helloTest;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);  //main方法</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String hello world</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 5: 0</span><br><span class="line">        line 6: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  args   [Ljava/lang/String;</span><br><span class="line">    MethodParameters:</span><br><span class="line">      Name                           Flags</span><br><span class="line">      args</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;helloTest.java&quot;</span><br></pre></td></tr></table></figure>

<p><strong>运行时常量池</strong></p>
<p>常量池时 *.class 文件中，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址。</p>
<p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20250317231536.png"></p>
<p><strong>元空间和永久代</strong></p>
<ul>
<li><strong>方法区只是JVM规范中定义的一个逻辑上的概念</strong>，并没有规定如何去实现它，不同的厂商有不同的实现方式。而<strong>永久代是 Hotspot 虚拟机特有的概念</strong>，<strong>Java8开始被元空间取代</strong>，永久代和元空间都可以理解为方法区的实现。</li>
<li>JVM 规范说方法区在逻辑上是堆的一部分，但目前实际上是与 Java 堆分开的（Non-Heap）。</li>
<li>存储内容不同，元空间存储类的元信息和运行时常量池，而静态变量与字符串常量池等并入堆中。相当于<strong>永久代的数据被分到了堆和元空间中</strong>。</li>
</ul>
<p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20250317233035.png"></p>
<h2 id="3-执行引擎"><a href="#3-执行引擎" class="headerlink" title="3. 执行引擎"></a><strong>3. 执行引擎</strong></h2><p>执行引擎是JVM的核心组件之一，其主要任务是执行由<code>javac</code>编译生成的<code>.class</code>文件中的字节码。</p>
<p><strong>原理</strong></p>
<ul>
<li><strong>输入</strong>：字节码指令（Bytecode）。  </li>
<li><strong>输出</strong>：对应平台上的本地机器指令。  </li>
<li><strong>目标</strong>：通过解释或编译的方式，将字节码转换为底层硬件可以直接执行的二进制指令。</li>
</ul>
<p><strong>作用</strong></p>
<p>执行引擎充当了字节码与底层硬件之间的桥梁，确保Java程序能够在不同平台上运行。</p>
<h2 id="4-本地库接口"><a href="#4-本地库接口" class="headerlink" title="4. 本地库接口"></a><strong>4. 本地库接口</strong></h2><p>本地库接口（Native Interface）是JVM与底层操作系统或其他语言交互的桥梁。</p>
<p><strong>主要功能</strong></p>
<ol>
<li>提供调用C&#x2F;C++等本地方法的能力，使得Java可以利用底层系统的功能（如文件操作、网络通信等）。  </li>
<li>支持通过JNI（Java Native Interface）实现Java与其他语言的融合。</li>
</ol>
<p><strong>作用</strong></p>
<p>本地库接口扩展了Java的功能范围，弥补了Java在某些底层操作上的不足。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 常见使用场景与缓存问题</title>
    <url>/2024/10/20/redis/</url>
    <content><![CDATA[<p>Redis 是一个开源的的内存数据结构存储系统，常用作数据库、缓存和消息代理。它支持多种数据结构，如字符串、哈希、列表、集合等，具备高性能和灵活性。</p>
<h3 id="常见使用场景"><a href="#常见使用场景" class="headerlink" title="常见使用场景"></a>常见使用场景</h3><h3 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1. 缓存"></a>1. 缓存</h3><p>将热点数据存放在内存中，作为缓存对象以加速数据的读取，减轻数据库的负担。这种方法可以显著提高应用的响应速度，尤其是在频繁访问的数据场景中。</p>
<ul>
<li><strong>常见缓存策略</strong>：<ul>
<li><strong>LRU（Least Recently Used）</strong>：淘汰最少使用的缓存数据。</li>
<li><strong>TTL（Time To Live）</strong>：设置缓存数据的有效时间，过期后自动删除。</li>
</ul>
</li>
</ul>
<h3 id="2-会话缓存"><a href="#2-会话缓存" class="headerlink" title="2. 会话缓存"></a>2. 会话缓存</h3><p>可以使用 Redis 来统一存储多台应用服务器的会话信息。通过将会话信息存储在 Redis 中，当应用服务器不再存储用户的会话信息时，系统变得无状态。这意味着用户可以请求任意一台应用服务器，这样更容易实现高可用性和可伸缩性。</p>
<ul>
<li><strong>Redis会话缓存 的优势</strong>：<ul>
<li><strong>持久化</strong>：Redis 提供数据持久化机制（把内存中的数据写到磁盘中去），可以在服务器重启后恢复会话数据。</li>
<li><strong>高并发</strong>：Redis 支持高并发访问，可以处理大量的会话请求。</li>
<li><strong>跨区域访问</strong>：多个服务器可以共享同一份会话数据，方便跨区域部署。</li>
</ul>
</li>
</ul>
<h3 id="3-消息队列（发布-订阅功能）"><a href="#3-消息队列（发布-订阅功能）" class="headerlink" title="3. 消息队列（发布&#x2F;订阅功能）"></a>3. 消息队列（发布&#x2F;订阅功能）</h3><p>Redis 的列表（List）或发布&#x2F;订阅功能，使得系统能够轻松实现消息队列。 虽然 Redis 的 List 是一个双向链表，可以通过 LPUSH 和 RPOP 命令写入和读取消息，但在高并发和复杂场景下，使用专门的消息中间件，如 Kafka 或 RabbitMQ，通常更为合适。</p>
<ul>
<li><strong>Redis List</strong>:<ul>
<li>适合于简单的消息队列实现，易于使用且性能优越。</li>
<li>可以快速处理消息的推送和消费，适合较低并发的场景。</li>
</ul>
</li>
</ul>
<h3 id="4-排行榜"><a href="#4-排行榜" class="headerlink" title="4. 排行榜"></a>4. 排行榜</h3><p>通过 Redis 的有序集合（ZSet），可以实现实时排行榜。每当用户获得新的分数或积分时，只需将该用户的分数更新到有序集合中，Redis 会自动维护排名。这种方式非常高效，可以支持大规模用户的实时排名需求。</p>
<ul>
<li><strong>实现方式</strong>：<ul>
<li>使用 <code>ZADD</code> 命令将用户分数添加到有序集合中。</li>
<li>使用 <code>ZRANGE</code> 或 <code>ZREVRANGE</code> 命令获取排名前 N 的用户。</li>
</ul>
</li>
</ul>
<h3 id="Redis-缓存问题"><a href="#Redis-缓存问题" class="headerlink" title="Redis 缓存问题"></a>Redis 缓存问题</h3><p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20241026155821.png"></p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指客户端请求的数据在数据库中根本不存在，这样缓存永远不会生效，导致请求穿透缓存直接打到数据库，对数据库造成压力。</p>
<p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20241026175234.png" alt="缓存穿透示意图"></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li><p><strong>缓存空对象</strong></p>
<ul>
<li><strong>优点</strong>：实现简单，维护方便。</li>
<li><strong>缺点</strong>：额外消耗内存（针对这个问题一般会设置一个较短的过期时间 TTL）。</li>
</ul>
</li>
<li><p><strong><a href="https://lualvis.github.io/2024/10/20/BloomFilter/">布隆过滤器</a></strong></p>
<ul>
<li>通过使用布隆过滤器，可以在请求到达数据库之前先检查请求的数据是否存在于数据库中，减少无效请求对数据库的压力。</li>
<li><strong>优点</strong>：内存占用少，没有多余key</li>
<li><strong>缺点</strong>：实现复杂，存在误判可能</li>
</ul>
</li>
</ul>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指在同一时间段大量的缓存 key 同时失效或者 Redis 服务宕机，导致大量请求直接到达数据库，造成数据库压力过大甚至宕机。这里与缓存击穿的区别在于，缓存击穿是指并发查同一条缓存 key 过期的数据，而缓存雪崩是缓存中大量不同数据同时过期，导致许多请求查不到数据，进而查数据库。</p>
<p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20241026173240.png" alt="缓存雪崩示意图"></p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li><strong>给不同 key 的 TTL 加上一个随机值</strong>（例如 1-5 分钟）。</li>
<li><strong>利用 Redis 集群</strong> 提高服务的可用性。</li>
<li><strong>给缓存业务添加降级限流策略</strong>。</li>
<li><strong>给业务添加多级缓存</strong>。</li>
</ul>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿问题也叫热点 key 问题，就是一个被<strong>高并发</strong>访问并且<strong>缓存重建业务较复杂</strong>的 key 突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p>
<p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20241026182327.png" alt="缓存击穿示意图"></p>
<h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p><img src="https://gitee.com/Luyseon/blogimage/raw/master/img/20241026184306.png"></p>
<ul>
<li><strong>互斥锁</strong><ul>
<li><strong>优点</strong>：<ul>
<li>没有额外的内存消耗</li>
<li>保证了数据的一致性</li>
<li>实现简单</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>线程需要等待，性能受影响</li>
<li>可能有死锁的风险</li>
</ul>
</li>
</ul>
</li>
<li><strong>逻辑过期</strong>：<ul>
<li><strong>优点</strong>：线程无需等待，性能较好</li>
<li><strong>缺点</strong>：<ul>
<li>不保证一致性</li>
<li>有额外的内存消耗</li>
<li>实现复杂</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>缓存问题</tag>
      </tags>
  </entry>
</search>
